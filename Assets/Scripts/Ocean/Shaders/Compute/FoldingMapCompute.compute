#pragma kernel CSMain

RWTexture2D<float4> foldingMap;
RWTexture2D<float4> heightMap;

float foamAmount;
float stepSize;
float oceanResolution;

[numthreads(1,1,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    float dx;
    float dz;
    float dxz;
    
    if(id.x == 0)
    {
        const float dD = heightMap[uint2(id.x + 1, id.y)].x - heightMap[id.xy].x;
        dx = dD/stepSize;
    }
    else if(id.x == oceanResolution - 1)
    {
        const float dD = heightMap[id.xy].x - heightMap[uint2(id.x - 1, id.y)].x;
        dx = dD/stepSize;
    }
    else
    {
        const float dD = heightMap[uint2(id.x + 1, id.y)].x - heightMap[uint2(id.x - 1, id.y)].x;
        dx = dD/ (2 *stepSize);
    }

    if(id.y == 0)
    {
        const float dD = heightMap[uint2(id.x, id.y + 1)].z - heightMap[id.xy].z;
        dz = dD/stepSize;
        
        const float dD2 = heightMap[uint2(id.x, id.y + 1)].x - heightMap[id.xy].x;
        dxz = dD2/stepSize;

    }
    else if(id.y == oceanResolution - 1)
    {
        const float dD = heightMap[id.xy].z - heightMap[uint2(id.x, id.y - 1)].z;
        dz = dD/stepSize;
        
        const float dD2 = heightMap[id.xy].x - heightMap[uint2(id.x, id.y - 1)].x;
        dxz = dD2/stepSize;
    }
    else
    {
        const float dD = heightMap[uint2(id.x, id.y + 1)].z - heightMap[uint2(id.x, id.y - 1)].z;
        dz = dD/ (2 *stepSize);
        
        const float dD2 = heightMap[uint2(id.x, id.y + 1)].x - heightMap[uint2(id.x, id.y - 1)].x;
        dxz = dD2/ (2 *stepSize);
    }

    const float jacobian = clamp(foamAmount - ((1 +dx) * (1 +dz) - dxz * dxz)
        , 0.0f, 1.0f) * 2;
    foldingMap[id.xy] = float4(jacobian, jacobian, jacobian, 1);
}
