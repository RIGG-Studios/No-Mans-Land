#pragma kernel CSMain

RWTexture2D<float4> h0;

RWTexture2D<float4> hk;
RWTexture2D<float4> hk2;
RWTexture2D<float4> nk;

float time;
int oceanResolution;
float lengthScale;
float choppiness;

float2 ComplexMultiply(float2 a, float2 b);

[numthreads(1,1,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    const float pi = 3.14159265358979323f;
    const float gravity = 9.81f;
    
    const float2 x = id.xy - (float)oceanResolution/2.0f;
    const float2 kVec = float2(pi * 2.0f * x.x/(int)lengthScale, pi * 2.0f * x.y/(int)lengthScale);
    
    float kMag = length(kVec);
    if(kMag < 0.00001f)
        kMag = 0.00001f;

    const float w = sqrt(gravity * kMag);
    
    const float2 spectrum = h0[id.xy].xy;
    const float2 spectrumConj = spectrum * float2(1.0f, -1.0f);

    const float cosWT = cos(w * time);
    const float sinWT = sin(w * time);

    const float2 expIWT = float2(cosWT, sinWT);
    const float2 expIWTInv = float2(cosWT, -sinWT);

    const float2 fourierComponent = ComplexMultiply(spectrum, expIWT) + ComplexMultiply(spectrumConj, expIWTInv);
    const float dx = kVec.x / kMag;
    const float dy = kVec.y / kMag;

    hk[id.xy] = float4(fourierComponent.x * dx * choppiness, 0, fourierComponent.x, 0);
    hk2[id.xy] = float4(fourierComponent.x * dy * choppiness, 0, 0, 0);
    nk[id.xy] = float4(-kVec.x * fourierComponent.x, 0, -kVec.y * fourierComponent.x, 0);
}

float Mag(float2 vec)
{
    return sqrt(pow(vec.x, 2) + pow(vec.y, 2));
}

float2 ComplexMultiply(float2 a, float2 b)
{
    return float2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);
}
